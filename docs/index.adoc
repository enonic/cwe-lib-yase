= Explorer library documentation
:toc: right
//:source-highlighter: coderay
//:source-highlighter: highlightjs
//:source-highlighter: prettify
//:source-highlighter: pygments

The explorer library contains common code used in the main Explorer application and code required to implement collectors and searches.

== Include library

You can include the library in your application build.gradle file under the dependencies section:

.build.gradle
[source,java]
----
dependencies {
	include 'com.enonic.lib:lib-explorer:1.0.0-SNAPSHOT'
}
----

== Collector

Include the library in your application as documented above.

In order for a collector to work it needs to provide 2 resources:

1. A webpack bundle using semantic-ui-react-formik-functional.
1. A task that does the collecting.

In order for the main Explorer application to know where these resources is located a collector application needs to register itself:

=== Register / unregister
.main.es
[source,java]
----
import {register} from '/lib/explorer/collector/register';
import {unregister} from '/lib/explorer/collector/unregister';

register({
	appName: app.name,
	collectTaskName: 'collect',
	configAssetPath: 'react/Collector.esm.js',
	displayName: 'My collector'
});

__.disposer(() => {
	unregister({
		appName: app.name
	});
});
----

=== React bundle

Setting up a build system to provide the react bundle can be quite complex.

Thus we have made a starter-collector for you to use and learn from.

Some important ingredients are:

- node-gradle-plugin
. webpack
. babel
. node_modules
.. @babel/preset-env
.. @babel/preset-react
.. @purtuga/esm-webpack-plugin
.. @h3t/semantic-ui-react-formik-functional

=== Task

Developing a task to collect data can also be quite complex.

Have a look at the app-collector-simple to see an example.

Some important ingredients are:

- Progress
. Create/modify/delete
. Journal

== Searching

Include the library in your application as documented above.

=== Selecting interface

There are numerous ways to pick an interface, using a custom selector is a pretty good solution.

==== Custom selector

The application provides a service that can be used by a custom selector in a site application.

.controller.xml
[source,xml]
----
<input name="interface" type="CustomSelector">
	<label>Interface</label>
	<occurrences minimum="1" maximum="1"/>
	<config>
		<service>interfaceSelector</service>
	</config>
</input>
----

The service can currently only be accessed with any of these roles:

* cms.admin
* cms.cm.app
* cms.expert
* system.admin
* system.admin.login

=== Providing a search result

There are numerous ways to provide a search result.

Perhaps you want to provide a JSON service to be used with a react frontend, or do a static HTML page by rendering server-side.

Common to all solutions is that you have to call the search function, and perhaps manipulate the result to your liking.

Below is an example of this:

.controller.es
[source,java]
----
import {search} from '/lib/explorer/search';

export function get({
	params
}) {
	const {
		facetCategories,
		pages,
		pagination,
		hits,
		removedStopWords,
		synonymsObj,
		total = 0
	} = search({
		clearCache,
		//count: 10,
		facets: {
			language: params.language,
			'information-type': params['information-type'],
			source: params.source
		},
		interface: interfaceName,
		locale,
		name,
		page,
		searchString
	});
}
----
